export module Day2;
import Advent2024;
import parser;

bp: namespace == boost::parser;

Day2: namespace = {

    export day : type = {
        this: Advent2024::day;

        operator= : (out this,  lines, part_two, verbose, argint) = {
            Advent2024::day = (lines, part_two, verbose, argint);
        }

        unsafe_offset : (this, levels: std::vector<int>) -> std::optional<int> = {
            if levels[1] == levels[0] {
                if m_verbose {
                    std::cout << "Initial values (levels[0])$ and (levels[1])$ are equal, not safe" << std::endl;
                }
                return 0;    
            }
            else {
                mindiff := -3;
                maxdiff := -1;
                if levels[1] > levels[0] {
                    mindiff = 1;
                    maxdiff = 3;
                }
                liter := levels.begin();
                lastlevel := levels[0];
                liter++;
                offset := 1;
                while liter != levels.end()
                next offset++
                {
                    diff := liter* - lastlevel;
                    if mindiff <= diff <= maxdiff {
                        lastlevel = liter*;
                        liter++;
                    }
                    else {
                        if m_verbose {
                            std::cout << "Neighboring values (lastlevel)$ and (liter*)$ not within diff range (mindiff)$ -> (maxdiff)$, not safe" << std::endl;
                        }
                        return offset;
                    }
                }
                return std::nullopt;
            }
        }

        run : (override this) -> int = {
            
            total : int = 0;

            for m_lines do (line) {
                // Each line contains 'Game <number>: <turn>; <turn>; <turn>'
                // A turn is <dice>, <dice>, <dice>
                // A dice is <number> <word>
                levels : std::vector<int> = ();
                if !bp::parse(line, bp::int_*, bp::ws, levels) {
                    std::cerr << "Parsing failure on *(line)$*!" << std::endl;
                    exit(1);
                }
                safe := true;
                if levels.size() < (2 as size_t) {
                    if m_verbose {
                        std::cout << "Too small at (levels.size())$, not safe" << std::endl;
                    }
                    safe = false;
                }
                else {
                    if unsafe_offset(levels) != std::nullopt {
                        safe = false;
                    }
                }
                if safe {
                    if m_verbose {
                        std::cout << "safe" << std::endl;
                    }
                    total++;
                }
            }
            return total;
        }
    }
}