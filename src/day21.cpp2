export module Day21;
import Advent2024;

Day21: namespace = {
    export day : type = {
        this: Advent2024::day;

        operator= : (out this,  lines, part_two, m_verbose, argint) = {
            Advent2024::day = (lines, part_two, m_verbose, argint);
        }

        coords: type = {
            public x: i32;
            public y: i32;

            hash: (this) -> u64 = {
                return unchecked_narrow<u64>(x) | (unchecked_narrow<u64>(y) << 32);
            }
            operator=: (out this, that) = {
                this.x = that.x;
                this.y = that.y;
            }
            operator=: (implicit out this) = {
                this.x = 0;
                this.y = 0;
            }
            operator=: (out this, hash: u64) = {
                this.x = unchecked_narrow<i32>(hash & 0xFFFFFFFF);
                this.y = unchecked_narrow<i32>((hash >> 32) & 0xFFFFFFFF);
            }
            operator=: (out this, x: i32, y: i32) = {
                this.x = x;
                this.y = y;
            }
            operator==: (this, that) -> bool = {
                return this.x == that.x && this.y == that.y;
            }
            operator+: (this, that) -> coords = {
                return coords(this.x + that.x, this.y + that.y);
            }
            operator-: (this, that) -> coords = {
                return coords(this.x - that.x, this.y - that.y);
            }
        }

        srcdst : type = {
            public src: char;
            public dst: char;

            hash: (this) -> u16 = {
                return unchecked_narrow<u16>(unchecked_narrow<u8>(src) << 8 | unchecked_narrow<u8>(dst));
            }
            operator=: (out this, that) = {
                this.src = that.src;
                this.dst = that.dst;
            }
            operator=: (implicit out this) = {
                this.src = 0;
                this.dst = 0;
            }
            operator=: (out this, hash: u16) = {
                this.src = unchecked_narrow<char>((hash >> 8) & 0xFF);
                this.dst = unchecked_narrow<char>(hash & 0xFF);
            }
            operator=: (out this, src: char, dst: char) = {
                this.src = src;
                this.dst = dst;
            }
        }

        robotconfig: type == std::unordered_map<char, coords>;

        moveset: type == std::unordered_set<std::string>;
        movemap: type == std::unordered_map<u16, moveset>;
        directmovemap: type == std::unordered_map<u16, std::string>;
        movecountmap: type == std::unordered_map<u16, u64>;

        movecount: type = {
            public map: movecountmap;
            public last: char;
            operator=: (out this, that) = {
                this.map = that.map;
                this.last = that.last;
            }
            operator=: (implicit out this) = {
                this.map = movecountmap();
                this.last = 0;
            }
            operator=: (out this, map: movecountmap, last: char) = {
                this.map = map;
                this.last = last;
            }

            operator[]: (inout this, key: u16) -> forward_ref _ = {
                return map[key];
            }
            at: (this, key: u16) -> int = {
                return map.at(key);
            }
            count: (this, key: u16) -> int = {
                return map.count(key);
            }
            begin: (this) -> movecountmap::const_iterator = {
                return map.begin();
            }
            end: (this) -> movecountmap::const_iterator = {
                return map.end();
            }
            size: (this) -> size_t = {
                return map.size();
            }

            display: (this) = {
                for map do (kv) {
                    std::cout << " Move (kv.first >> 8:c)$(kv.first & 0xFF:c)$: (kv.second)$" << std::endl;
                }
                std::cout << " Last move: (last:c)$" << std::endl;
            }
        }

        movegraph: type == std::unordered_map<u16, movecount>;

        robot: type = {
            public keys: robotconfig;
            public reverse_keys: std::unordered_map<u64, char>;
            public position: coords;
            public moves: movemap; // Cache of moves between keys.


            private move_x: (this, other: robot, copy src_coords: coords, dst_coords: coords, inout seq: std::string) -> coords = {
                if (src_coords.x != dst_coords.x) {
                    while (src_coords.x != dst_coords.x) {
                        if (src_coords.x < dst_coords.x) {
                            src_coords.x += 1;
                            seq += '>';
                        }
                        else {
                            src_coords.x -= 1;
                            seq += '<';
                        }
                        if !other.reverse_keys.count(src_coords.hash()) {
                            seq += 'X'; // Invalid path
                            break;
                        }
                    }
                }
                return src_coords;
            }

            private move_y: (this, other: robot, copy src_coords: coords, dst_coords: coords, inout seq: std::string) -> coords = {
                if (src_coords.y != dst_coords.y) {
                    while (src_coords.y != dst_coords.y) {
                        if (src_coords.y < dst_coords.y) {
                            src_coords.y += 1;
                            seq += 'v';
                        }
                        else {
                            src_coords.y -= 1;
                            seq += '^';
                        }
                        if !other.reverse_keys.count(src_coords.hash()) {
                            seq += 'X'; // Invalid path
                            break;
                        }
                    }
                }
                return src_coords;
            }

            private find_moves: (this, other: robot, src: char, dst: char) -> moveset = {
                // We assume that the fastest way will be either row-column or column-row.
                src_coords := other.keys.at(src);
                dst_coords := other.keys.at(dst);

                // First try row-col.
                rowcolseq: std::string = "";
                new_coords := move_x(other, src_coords, dst_coords, rowcolseq);
                new_coords = move_y(other, new_coords, dst_coords, rowcolseq);
                assert(new_coords.x == dst_coords.x && new_coords.y == dst_coords.y);
                // Now try col-row.
                colrowseq: std::string = "";
                new_coords = move_y(other, src_coords, dst_coords, colrowseq);
                new_coords = move_x(other, new_coords, dst_coords, colrowseq);
                assert(new_coords.x == dst_coords.x && new_coords.y == dst_coords.y);
                outvec := moveset();
                if rowcolseq.find("X") == std::string::npos {
                    _ = outvec.insert(rowcolseq);
                }
                if colrowseq.find("X") == std::string::npos {
                    _ = outvec.insert(colrowseq);
                }
                return outvec;  
            }

            optimize_our_moveset: (inout this) = {
                // Expand each moveset by one repetition, and keep only the shortest ones.
                outmoves := movemap();
                for moves do (kv) {
                    movehash := kv.first;
                    moveseqset := kv.second;
                    optimized_moves := optimize_moveset_single(moveseqset, this);
                    outmoves[movehash] = optimized_moves;
                }
                moves = outmoves;
            }

            optimize_moveset: (this, ourmoves: movemap, other: robot) -> movemap = {
            //optimize_moveset: (this, ourmoves: movemap, other: robot, saved_moves: directmovemap) -> movemap = {
                // Expand each moveset by one repetition, and keep only the shortest ones.
                outmoves := movemap();
                for ourmoves do (kv) {
                    movehash := kv.first;
                    moveseqset := kv.second;
                    optimized_moves := optimize_moveset_single(moveseqset, other);
                    outmoves[movehash] = optimized_moves;
                }
                return outmoves;
            }

            optimize_moveset_single: (this, ourmoves: moveset, other: robot) -> moveset = {
            //optimize_moveset_single: (this, ourmoves: moveset, other: robot, saved_moves: directmovemap) -> moveset = {
                outmoves := moveset();
                outinmoves := moveset();
                min_length: size_t = (1ULL << 63) - 1;
                for ourmoves do (mv) {
                    /*if other == this && mv.length() >= 2U && saved_moves.count(srcdst(mv[0], mv[1]).hash()) != 0 {
                        // Optimize using our own optimized moves.
                        optimized_mv: std::string = "";
                        for 0..<(mv.length() - 1) do (i) {
                            from_ch: char = mv[i];
                            to_ch: char = mv[i+1];
                            h: u16 = srcdst(from_ch, to_ch).hash();
                            optimized_mv += saved_moves.at(h);
                        }
                            if optimized_mv.length() < min_length {
                            min_length = optimized_mv.length();
                            outmoves.clear();
                            outinmoves.clear();
                        }
                        if optimized_mv.length() == min_length {
                            _ = outmoves.insert(optimized_mv);
                            _ = outinmoves.insert(mv);
                        }
                    }
                    else {
                    */
                        // Expand normally.
                        expanded_move := other.expand_sequence(moveset( (mv) ));
                        for expanded_move do (mv2) {
                            if mv2.length() < min_length {
                                min_length = mv2.length();
                                outmoves.clear();
                                outinmoves.clear();
                            }
                            if mv2.length() == min_length {
                                _ = outmoves.insert(mv2);
                                _ = outinmoves.insert(mv);
                            }
                        }
                    //}
                }
                return outinmoves;
            }

            precompute_moves: (this, other: robot) -> movemap = {
                outmoves := movemap();
                // Precompute all the moves between keys.
                for other.keys do (src_kv) {
                    src_key := src_kv.first;
                    for other.keys do (dst_kv) {
                        dst_key := dst_kv.first;
                        move_seq : moveset;
                        if src_key != dst_key {
                            move_seq = find_moves(other, src_key, dst_key);
                        } else {
                            move_seq = moveset();
                            _ = move_seq.insert("");
                        }
                        outmoves[srcdst(src_key, dst_key).hash()] = move_seq;
                    }
                }
                return outmoves;
            }

            graph_from_moves: (this, moves: movemap) -> movegraph = {
                outgraph := movegraph();
                // Precompute all the moves between keys.
                for moves do (kv) {
                    movehash := kv.first;
                    moveseqset := kv.second;
                    ourmove := "A" + moveseqset.begin()* + "A";
                    outgraph[movehash] = movecount();
                    for 0..<ourmove.length() - 1 do (i) {
                        nextmovehash: u16 = srcdst(ourmove[i], ourmove[i+1]).hash();
                        if !outgraph[movehash].count(nextmovehash) {
                            outgraph[movehash][nextmovehash] = 0;
                        }
                        outgraph[movehash][nextmovehash] += 1;
                    }
                    outgraph[movehash].last = ourmove[ourmove.length() - 1];
                }
                return outgraph;
            }

            operator=: (out this, keys_in: robotconfig) = {
            //operator=: (out this, keys_in: robotconfig, optimized: std::optional<directmovemap> = std::nullopt) = {
                keys = keys_in;
                reverse_keys = std::unordered_map<u64, char>();
                position = keys['A'];
                moves = movemap();
                for keys do (kv) {
                    key := kv.first;
                    value := kv.second;
                    reverse_keys[value.hash()] = key;
                }
                /*
                if optimized.has_value() {
                    for optimized.value() do (kv) {
                        key := kv.first;
                        value := kv.second;
                        moves[key] = moveset();
                        _ = moves[key].insert(value);
                    }
                }
                else {
                */
                    moves = precompute_moves(this);
                //}
            }



            operator=: (implicit out this) = {
                keys = robotconfig();
                reverse_keys = std::unordered_map<u64, char>();
                position = coords(0,0);
                moves = movemap();
            }

            operator=: (out this, that) = {
                keys = that.keys;
                reverse_keys = that.reverse_keys;
                position = that.position;
                moves = that.moves;
            }

            operator==: (this, that) -> bool = {
                return this.keys == that.keys && this.position == that.position && this.moves == that.moves;
            }

            expand_sequence: (this, inseq: moveset) -> moveset = {
                outseq := moveset();
                workqueue := std::deque<std::pair<std::string, std::string>>();
                for inseq do (seq) {
                    _ = workqueue.emplace_back(std::make_pair(std::string(""), "A" + seq));
                }
                while workqueue.size() {
                    this_pair := workqueue.front();
                    stringsofar := this_pair.first;
                    movestocome := this_pair.second;
                    if movestocome.length() < 2U {
                        // We're done. 
                        if outseq.size() == 0 || stringsofar.length() < outseq.begin()*.length() {
                            outseq.clear();
                        }
                        if outseq.size() == 0 || stringsofar.length() == outseq.begin()*.length() {
                            _ = outseq.insert(stringsofar);
                        }
                    }
                    else {
                        // Grab the current move.
                        nextmovehash: u16 = srcdst(movestocome[0], movestocome[1]).hash();
                        assert(moves.count(nextmovehash) != 0);
                        nextmoves := moves.at(nextmovehash);
                        for nextmoves do (thismove) {
                            _ = workqueue.emplace_back(stringsofar + thismove + "A", std::string(movestocome.data()+1, movestocome.length()-1));
                        }
                    }
                    workqueue.pop_front();
                }
                return outseq;
            }

            expand_fast_by_one: (this, inseq: moveset) -> moveset = {
                outseq := moveset();
                for inseq do (seq) {
                    instr := "A" + seq;
                    outstr: std::string = "";
                    for 0..<(instr.length() - 1) do (i) {
                        nextmovehash: u16 = srcdst(instr[i], instr[i+1]).hash();
                        assert(moves.count(nextmovehash) != 0);
                        nextmoves := moves.at(nextmovehash);
                        outstr += nextmoves.begin()* + "A";
                    }
                    if outseq.size() == 0 || outstr.length() < outseq.begin()*.length() {
                        outseq.clear();
                    }
                    if outseq.size() == 0 || outstr.length() == outseq.begin()*.length() {
                        _ = outseq.insert(outstr);
                    }
                }

                return outseq;
            }

            display: (this) = {
                for 0..<4 do (y) {
                    for 0..<3 do (x) {
                        pos := coords(x,y);
                        std::cout << " ";
                        if reverse_keys.count(pos.hash()) {
                            std::cout << reverse_keys.at(pos.hash());
                        }
                        else {
                            std::cout << '.';
                        }
                        if pos.x == position.x && pos.y == position.y {
                            std::cout << "*";
                        }
                        else {
                            std::cout << " ";
                        }
                    }
                    std::cout << std::endl;
                }
            }
        }


        playback_sequence: (this, inout robots: std::vector<robot>, sequence: std::string) -> std::string = {
            output: std::string = "";
            for sequence do (base_ch) {
                ch : char = base_ch;
                i := 0;
                if m_verbose {
                    std::cout << "Top of loop:" << std::endl;
                    j := 0;
                    for robots next j++ do (ourrobot) {
                        std::cout << " Robot (j)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$):" << std::endl;
                        ourrobot.display();
                        std::cout << std::endl;
                    }
                }
                robot_loop: for robots next i++ do (inout ourrobot) {
                    if m_verbose {
                        std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) processing '(ch)$'" << std::endl;
                    }
                    if ch == '^' {
                        ourrobot.position.y -= 1;
                    }
                    else if ch == 'v' {
                        ourrobot.position.y += 1;
                    }
                    else if ch == '<' {
                        ourrobot.position.x -= 1;
                    }
                    else if ch == '>' {
                        ourrobot.position.x += 1;
                    }
                    else if ch >= '0' && ch <= '9' {
                        // Check we're the last robot.
                        if m_verbose {
                            std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) outputting '(ch)$'" << std::endl;
                        }
                        assert(i == robots.size() - 1);
                        output += ch;
                        break robot_loop;
                    }
                    if ch == 'A' {
                        if m_verbose {
                            std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) got A, moving to next robot" << std::endl;
                        }
                        assert(ourrobot.keys.count(ourrobot.reverse_keys.at(ourrobot.position.hash())));
                        ch = ourrobot.reverse_keys.at(ourrobot.position.hash());
                        if i == robots.size() - 1 {
                            if m_verbose {
                                std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) outputting '(ch)$'" << std::endl;
                            }
                            output += ch;
                            break robot_loop;
                        }
                        // Continue to the next robot.
                    }
                    else {
                        if m_verbose {
                            std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) moved to '(ourrobot.reverse_keys.at(ourrobot.position.hash()))$'" << std::endl;
                        }
                        assert(ourrobot.reverse_keys.count(ourrobot.position.hash()));
                        break robot_loop;  // go to next character
                    }
                    if m_verbose {
                        std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) continuing with '(ch)$'" << std::endl;
                    }
                }

            }
            return output;
        }

        graph_from_sequence: (this, seq: std::string) -> movecount = {
            ourgraph := movecount();
            inseq := "A" + seq;
            for 0..<(inseq.length() - 1) do (i) {
                nextmovehash: u16 = srcdst(inseq[i], inseq[i+1]).hash();
                if !ourgraph.count(nextmovehash) {
                    ourgraph[nextmovehash] = 0;
                }
                ourgraph[nextmovehash] += 1;
            }
            ourgraph.last = inseq[inseq.length() - 1];
            return ourgraph;
        }

        expand_graph_from_moves: (this, graph: movecount, moves: movegraph) -> movecount = {
            outgraph := movecount();

            for graph do (kv) {
                movehash := kv.first;
                count := kv.second;
                assert(moves.count(movehash) != 0);
                movemap := moves.at(movehash);
                for movemap do (mvkv) {
                    moveseq := mvkv.first;
                    movecount := mvkv.second;
                    if !outgraph.count(moveseq) {
                        outgraph[moveseq] = 0;
                    }
                    outgraph[moveseq] += count * movecount;
                }
            }
            // And now set the last character.
            lastmovehash: u16 = srcdst(graph.last, 'A').hash();
            assert(moves.count(lastmovehash) != 0);
            lastmovemap := moves.at(lastmovehash);
            outgraph.last = lastmovemap.last;

            return outgraph;
        }

        // Borrowed version.
        move_map_t: type == std::unordered_map<u64, char>;

        move_map: const move_map_t = ( ( coords( 1, 0 ).hash(), '>' ),
                                    ( coords( 0, 1 ).hash(), 'v' ),
                                    ( coords( -1, 0 ).hash(), '<' ),
                                    ( coords( 0, -1 ).hash(), '^' ),
                                    ( coords( 0, 0 ).hash(), 'A' ) );
        char_row_t: type == std::vector<char>;
        codes_list_t: type == std::vector<char_row_t>;

        memo_inputs: @struct type = {
            key: char;
            pos: coords;
            iter: int;
            hash: (this) -> size_t = {
                return std::hash<char>()(key) ^ (pos.hash() << 8u) ^ (std::hash<int>()(iter) << 24u);
            }
        }

        memo_map_t: type == std::unordered_map<size_t, int64_t>;

        //this returns the sequence of moves to go from current -> desired_1 -> desired_2
        //the order of the moves is step1 and then step2 (X then Y or Y then X)
        //forbid is the empty space that we are not allowed to move to
        //if we enter forbid then return vector is empty
        compute_moves: (this, step1: coords, step2: coords, copy current: coords, desired_1: coords, desired_2: coords, forbid: coords) -> char_row_t =
        {
            moves_vector := char_row_t();
            while (step1 != coords(0, 0) && current != desired_1) {
                current = current + step1;
                h := step1.hash();
                moves_vector.push_back(move_map.at(h));
                if current == forbid {
                    return char_row_t();
                }
            }
            while (step2 != coords(0, 0) && current != desired_2) {
                current = current + step2;
                h := step2.hash();
                moves_vector.push_back(move_map.at(h));
                if current == forbid {
                    return char_row_t();
                }
            }
            moves_vector.push_back(move_map.at(coords(0, 0).hash()));
            return moves_vector;
        }

        //this returns either 1 or 2 possible moves to get to the desired key
        //for example <<^A or ^<<A
        //<^<A is never omptimal so it is never considered
        compute_all_moves: (this, keys: robotconfig, key: char, copy current_pos: coords, forbid: coords) -> codes_list_t =
        {
            all_moves := codes_list_t();

            desired_pos: coords = keys.at(key);
            diff: coords = desired_pos - current_pos;
            x_step: coords;
            if diff.x == 0 {
                x_step = coords(0, 0);
            } else {
                x_step = coords(diff.x / std::abs(diff.x), 0);
            }
            y_step: coords;
            if diff.y == 0 {
                y_step = coords(0, 0);
            } else {
                y_step = coords(0, diff.y / std::abs(diff.y));
            }

            //2 options
            step1: coords = x_step;
            desired_1: coords = coords(desired_pos.x, current_pos.y);

            step2: coords = y_step;
            desired_2: coords = coords(current_pos.x, desired_pos.y);
            move1 := compute_moves(step1, step2, current_pos, desired_1, desired_pos, forbid);
            move2 := compute_moves(step2, step1, current_pos, desired_2, desired_pos, forbid);

            if !move1.empty() {
                all_moves.push_back(move1);
            }
            if !move2.empty() && move2 != move1 {
                all_moves.push_back(move2);
            }

            current_pos = desired_pos;

            return all_moves;
        }

        compute_sequence: <first_iter_t: bool = false>(this, keys1: robotconfig, keys2: robotconfig, codes: char_row_t, forbid1: coords,
                                forbid2: coords, iter: int, max_iter: int, inout memo_map: memo_map_t) -> size_t =
        {
            keys_to_use: robotconfig;
            forbid_to_use: coords;
            if (first_iter_t) {
                keys_to_use = keys1;
                forbid_to_use = forbid1;
            } else {
                keys_to_use = keys2;
                forbid_to_use = forbid2;
            }
            current_pos: coords = keys_to_use.at('A');
            total_size: size_t = 0;
            for codes do (key) {
                moves_size: size_t = 0;
                keyvalue := memo_inputs(key, current_pos, iter).hash();
                if (memo_map.contains(keyvalue)) {
                    moves_size = memo_map[keyvalue];
                    current_pos = keys_to_use.at(key);
                } else {
                    all_moves := compute_all_moves(keys_to_use, key, current_pos, forbid_to_use);

                    if (iter < max_iter) {
                        values: std::array<size_t, 2> = ( (1ULL << 63) - 1, (1ULL << 63) - 1);
                        i: size_t = 0;
                        for all_moves do (seq) {
                            values.at(i) = compute_sequence(keys1, keys2, seq, forbid1, forbid2, iter + 1, max_iter, memo_map);
                            i++;
                        }
                        moves_size += std::min(values.at(0), values.at(1));
                    } else {
                        if all_moves.size() == 1 {
                            moves_size += all_moves.at(0).size();
                        } else {
                            moves_size += std::min(all_moves.at(0).size(), all_moves.at(1).size());
                        }
                    }
                    memo_map[keyvalue] = moves_size;
                }
                total_size += moves_size;
            }

            return total_size;
        }

        run : (override inout this) -> i64 = {
            total : i64 = 0;
            // First, let's find the quickest way to do any particular task.
            // We assume that it's always quicker to turn just once.
            
            // Configuration of robots.
            robot0_config: robotconfig = (
                ('A', (2,3)),
                ('0', (1,3)),
                ('1', (0,2)),
                ('2', (1,2)),
                ('3', (2,2)),
                ('4', (0,1)),
                ('5', (1,1)),
                ('6', (2,1)),
                ('7', (0,0)),
                ('8', (1,0)),
                ('9', (2,0))
            );

            robot1_config: robotconfig = (
                ('A', (2,0)),
                ('^', (1,0)),
                ('<', (0,1)),
                ('v', (1,1)),
                ('>', (2,1))
            );

            /*optimized_moves := directmovemap();
            optimized_moves[srcdst('<', '<').hash()] = "A";
            optimized_moves[srcdst('<', '>').hash()] = ">>A";
            optimized_moves[srcdst('<', 'A').hash()] = ">>^A";
            optimized_moves[srcdst('<', '^').hash()] = ">^A";
            optimized_moves[srcdst('<', 'v').hash()] = ">A";
            optimized_moves[srcdst('>', '>').hash()] = "A";
            optimized_moves[srcdst('>', '<').hash()] = "<<A";
            optimized_moves[srcdst('>', 'A').hash()] = "^A";
            optimized_moves[srcdst('>', 'v').hash()] = "<A";
            optimized_moves[srcdst('>', '^').hash()] = "<^A";
            optimized_moves[srcdst('^', '^').hash()] = "A";
            optimized_moves[srcdst('^', '<').hash()] = "v<A";
            optimized_moves[srcdst('^', '>').hash()] = "v>A";
            optimized_moves[srcdst('^', 'A').hash()] = ">A";
            optimized_moves[srcdst('^', 'v').hash()] = "vA";
            optimized_moves[srcdst('v', 'v').hash()] = "A";
            optimized_moves[srcdst('v', '^').hash()] = "^A";
            optimized_moves[srcdst('v', 'A').hash()] = "^>A";
            optimized_moves[srcdst('v', '<').hash()] = "<A";
            optimized_moves[srcdst('v', '>').hash()] = ">A";
            optimized_moves[srcdst('A', 'A').hash()] = "A";
            optimized_moves[srcdst('A', '<').hash()] = "v<<A";
            optimized_moves[srcdst('A', '>').hash()] = "vA";
            optimized_moves[srcdst('A', '<').hash()] = "<A";
            optimized_moves[srcdst('A', 'v').hash()] = "<vA";
            */
            robot0 := robot(robot0_config);
            robot1 := robot(robot1_config);
            robot1old := robot(robot1_config);

            //seq := playback_sequence(robots, "<vA<AA>>^AvAA<^A>A<v<A>>^AvA^A<vA>^A<v<A>^A>AAvA^A<v<A>A>^AAAvA<^A>A");
            //std::cout << "Day 21 output: (seq)$" << std::endl;

            robot01_moves := robot1.precompute_moves(robot0);
            //robot01_moves2 := robot1.optimize_moveset(robot01_moves, robot0);
            //for robot01_moves do (kv) {
            //    std::cout << "Robot0 to Robot1 Move (kv.first >> 8:c)$(kv.first & 0xFF:c)$: " << std::endl;
            //    for kv.second do (s) {
            //        std::cout << "  (s)$" << std::endl;
            //    }
            //    assert(robot01_moves2.count(kv.first) != 0);
            //    std::cout << " Optimized to:" << std::endl;
            //    for robot01_moves2.at(kv.first) do (s) {
            //        std::cout << "  (s)$" << std::endl;
            //    }
            //}


            //robot1_moves := robot1.precompute_moves(robot1);
            robot1.optimize_our_moveset();
            //robot1_moves2 := robot1.optimize_moveset(robot1_moves, robot1);
            //for robot1_moves do (kv) {
            //    std::cout << "Robot1 to Robot1 Move (kv.first >> 8:c)$(kv.first & 0xFF:c)$: " << std::endl;
            //    for kv.second do (s) {
            //        std::cout << "  (s)$" << std::endl;
            //    }
            //    assert(robot1_moves2.count(kv.first) != 0);
            //    std::cout << " Optimized to:" << std::endl;
            //    for robot1_moves2.at(kv.first) do (s) {
            //        std::cout << "  (s)$" << std::endl;
            //    }
            //}
            robot1_graph := robot1.graph_from_moves(robot1.moves);

            if m_verbose {
                std::cout << "Robot1 graph:" << std::endl;
                for robot1_graph do (kv) {
                    std::cout << " Move (kv.first >> 8:c)$(kv.first & 0xFF:c)$: (kv.second)$" << std::endl;
                }
                std::cout << std::endl;
            }
            reps: int;
            if m_part_two {
                reps = 25;
            }
            else {
                reps = 2;
            }

            for m_lines do (line) {
                if m_verbose {
                    std::cout << "Expanding line (line)$" << std::endl;
                }
                inseq := moveset();
                _ = inseq.insert(line);
                outseq := robot0.expand_sequence(inseq);
                //outseq2 := robot0.expand_sequence(inseq);
                if m_verbose {
                    std::cout << "After first expansion, sequences are:" << std::endl;
                    for outseq do (s) {
                        std::cout << " (s)$" << std::endl;
                    }
                    std::cout << std::endl;
                }
                outgraphs := std::vector<movecount>();
                for outseq do (s) {
                    outgraphs.push_back(graph_from_sequence(s));
                }
                if m_verbose {
                    std::cout << "After first expansion, graphs are:" << std::endl;
                    for outgraphs do (outgraph) {
                        outgraph.display();
                        std::cout << std::endl;
                    }
                }
                for 0..<reps do (i) {
                    newoutgraphs := std::vector<movecount>();
                    for outgraphs do (outgraph) {
                        newoutgraphs.push_back(expand_graph_from_moves(outgraph, robot1_graph));
                    }
                    if m_verbose {
                        std::cout << "After repetition (i)$, graphs are:" << std::endl;
                        for newoutgraphs do (outgraph) {
                            outgraph.display();
                            std::cout << std::endl;
                        }
                    }
                    //newoutseq := robot1old.expand_sequence(outseq);
                    //if m_verbose {
                    //   std::cout << "After repetition (i)$, old sequences (length (newoutseq.size())$) are:" << std::endl;
                    //    for newoutseq do (s) {
                    //        std::cout << " (s)$" << std::endl;
                    //    }
                    //    std::cout << std::endl;
                    //}
                    //newoutseq2 := robot1.expand_sequence(outseq2);
                    //if m_verbose {
                    //   std::cout << "After repetition (i)$, new sequences (length (newoutseq2.size())$) are:" << std::endl;
                    //    for newoutseq2 do (s) {
                    //        std::cout << " (s)$" << std::endl;
                    //    }
                    //    std::cout << std::endl;
                    //}
                    //outseq = newoutseq;
                    //outseq2 = newoutseq2;
                    outgraphs = newoutgraphs;
                }
                //complexity_old := outseq.begin()*.length() * std::stoi(line);
                //complexity_old2 := outseq2.begin()*.length() * std::stoi(line);
                complexity : u64 = (1ULL << 63) - 1;
                for outgraphs do (outgraph) {
                    graph_complexity: u64 = 0;
                    for outgraph do (kv) {
                        graph_complexity += kv.second;
                    }
                    if m_verbose {
                        std::cout << "Graph of (line)$ (complexity (graph_complexity)$):" << std::endl;
                        outgraph.display();
                        std::cout << std::endl;
                    }
                    if graph_complexity < complexity {
                        complexity = graph_complexity;
                    }
                }
                overall_complexity: u64 = complexity * std::stoi(line);

                memo_map := memo_map_t();
                codes := char_row_t();
                for line do (ch) {
                    codes.push_back(ch);
                }
                complexity_borrowed := compute_sequence<true>(robot0_config, robot1_config, codes, coords(0, 3), coords(0, 0), 0, reps, memo_map);
                _ = memo_map;
                overall_complexity_borrowed: u64 = complexity_borrowed * std::stoi(line);

                if m_verbose {
                    //std::cout << "Complexity in old algorithm for line (line)$ is (complexity_old)$" << std::endl;
                    //std::cout << "Complexity in old algorithm 2 for line (line)$ is (complexity_old2)$" << std::endl;
                    std::cout << "Complexity (my algorithm) for line (line)$ is (complexity)$ * (std::stoi(line))$ = (overall_complexity)$" << std::endl;
                    std::cout << "Complexity (borrowed algorithm) for line (line)$ is (complexity_borrowed)$ * (std::stoi(line))$ = (overall_complexity_borrowed)$" << std::endl;
                }
                total += overall_complexity_borrowed;
            }
            return total;
        }
    }
}