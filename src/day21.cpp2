export module Day21;
import Advent2024;

Day21: namespace = {
    export day : type = {
        this: Advent2024::day;

        operator= : (out this,  lines, part_two, m_verbose, argint) = {
            Advent2024::day = (lines, part_two, m_verbose, argint);
        }

        coords: type = {
            public x: i32;
            public y: i32;

            hash: (this) -> u64 = {
                return unchecked_narrow<u64>(x) | (unchecked_narrow<u64>(y) << 32);
            }
            operator=: (out this, that) = {
                this.x = that.x;
                this.y = that.y;
            }
            operator=: (implicit out this) = {
                this.x = 0;
                this.y = 0;
            }
            operator=: (out this, hash: u64) = {
                this.x = unchecked_narrow<i32>(hash & 0xFFFFFFFF);
                this.y = unchecked_narrow<i32>((hash >> 32) & 0xFFFFFFFF);
            }
            operator=: (out this, x: i32, y: i32) = {
                this.x = x;
                this.y = y;
            }
        }

        srcdst : type = {
            public src: char;
            public dst: char;

            hash: (this) -> u16 = {
                return unchecked_narrow<u16>(unchecked_narrow<u8>(src) << 8 | unchecked_narrow<u8>(dst));
            }
            operator=: (out this, that) = {
                this.src = that.src;
                this.dst = that.dst;
            }
            operator=: (implicit out this) = {
                this.src = 0;
                this.dst = 0;
            }
            operator=: (out this, hash: u16) = {
                this.src = unchecked_narrow<char>((hash >> 8) & 0xFF);
                this.dst = unchecked_narrow<char>(hash & 0xFF);
            }
            operator=: (out this, src: char, dst: char) = {
                this.src = src;
                this.dst = dst;
            }
        }

        moveset: type == std::unordered_set<std::string>;
        movemap: type == std::unordered_map<u16, moveset>;
        movecountmap: type == std::unordered_map<u16, u64>;

        movecount: type = {
            public map: movecountmap;
            public last: char;
            operator=: (out this, that) = {
                this.map = that.map;
                this.last = that.last;
            }
            operator=: (implicit out this) = {
                this.map = movecountmap();
                this.last = 0;
            }
            operator=: (out this, map: movecountmap, last: char) = {
                this.map = map;
                this.last = last;
            }

            operator[]: (inout this, key: u16) -> forward_ref _ = {
                return map[key];
            }
            at: (this, key: u16) -> int = {
                return map.at(key);
            }
            count: (this, key: u16) -> int = {
                return map.count(key);
            }
            begin: (this) -> movecountmap::const_iterator = {
                return map.begin();
            }
            end: (this) -> movecountmap::const_iterator = {
                return map.end();
            }
            size: (this) -> size_t = {
                return map.size();
            }

            display: (this) = {
                for map do (kv) {
                    std::cout << " Move (kv.first >> 8:c)$(kv.first & 0xFF:c)$: (kv.second)$" << std::endl;
                }
                std::cout << " Last move: (last:c)$" << std::endl;
            }
        }

        movegraph: type == std::unordered_map<u16, movecount>;

        robot: type = {
            public keys: std::unordered_map<char, coords>;
            public reverse_keys: std::unordered_map<u64, char>;
            public position: coords;
            public moves: movemap; // Cache of moves between keys.


            private move_x: (this, other: robot, copy src_coords: coords, dst_coords: coords, inout seq: std::string) -> coords = {
                if (src_coords.x != dst_coords.x) {
                    while (src_coords.x != dst_coords.x) {
                        if (src_coords.x < dst_coords.x) {
                            src_coords.x += 1;
                            seq += '>';
                        }
                        else {
                            src_coords.x -= 1;
                            seq += '<';
                        }
                        if !other.reverse_keys.count(src_coords.hash()) {
                            seq += 'X'; // Invalid path
                            break;
                        }
                    }
                }
                return src_coords;
            }

            private move_y: (this, other: robot, copy src_coords: coords, dst_coords: coords, inout seq: std::string) -> coords = {
                if (src_coords.y != dst_coords.y) {
                    while (src_coords.y != dst_coords.y) {
                        if (src_coords.y < dst_coords.y) {
                            src_coords.y += 1;
                            seq += 'v';
                        }
                        else {
                            src_coords.y -= 1;
                            seq += '^';
                        }
                        if !other.reverse_keys.count(src_coords.hash()) {
                            seq += 'X'; // Invalid path
                            break;
                        }
                    }
                }
                return src_coords;
            }

            private find_moves: (this, other: robot, src: char, dst: char) -> moveset = {
                // We assume that the fastest way will be either row-column or column-row.
                src_coords := other.keys.at(src);
                dst_coords := other.keys.at(dst);

                // First try row-col.
                rowcolseq: std::string = "";
                new_coords := move_x(other, src_coords, dst_coords, rowcolseq);
                new_coords = move_y(other, new_coords, dst_coords, rowcolseq);
                assert(new_coords.x == dst_coords.x && new_coords.y == dst_coords.y);
                // Now try col-row.
                colrowseq: std::string = "";
                new_coords = move_y(other, src_coords, dst_coords, colrowseq);
                new_coords = move_x(other, new_coords, dst_coords, colrowseq);
                assert(new_coords.x == dst_coords.x && new_coords.y == dst_coords.y);
                outvec := moveset();
                if rowcolseq.find("X") == std::string::npos {
                    _ = outvec.insert(rowcolseq);
                }
                if colrowseq.find("X") == std::string::npos {
                    _ = outvec.insert(colrowseq);
                }
                return outvec;  
            }

            precompute_moves: (this, other: robot) -> movemap = {
                outmoves := movemap();
                // Precompute all the moves between keys.
                for other.keys do (src_kv) {
                    src_key := src_kv.first;
                    for other.keys do (dst_kv) {
                        dst_key := dst_kv.first;
                        move_seq : moveset;
                        if src_key != dst_key {
                            move_seq = find_moves(other, src_key, dst_key);
                        } else {
                            move_seq = moveset();
                            _ = move_seq.insert("");
                        }
                        outmoves[srcdst(src_key, dst_key).hash()] = move_seq;
                    }
                }
                return outmoves;
            }

            graph_from_moves: (this, moves: movemap) -> movegraph = {
                outgraph := movegraph();
                // Precompute all the moves between keys.
                for moves do (kv) {
                    movehash := kv.first;
                    moveseqset := kv.second;
                    ourmove := "A" + moveseqset.begin()* + "A";
                    outgraph[movehash] = movecount();
                    for 0..<ourmove.length() - 1 do (i) {
                        nextmovehash: u16 = srcdst(ourmove[i], ourmove[i+1]).hash();
                        if !outgraph[movehash].count(nextmovehash) {
                            outgraph[movehash][nextmovehash] = 0;
                        }
                        outgraph[movehash][nextmovehash] += 1;
                    }
                    outgraph[movehash].last = ourmove[ourmove.length() - 1];
                }
                return outgraph;
            }

            operator=: (out this, keys_in: std::unordered_map<char, coords>) = {
                keys = keys_in;
                reverse_keys = std::unordered_map<u64, char>();
                position = keys['A'];
                moves = movemap();
                for keys do (kv) {
                    key := kv.first;
                    value := kv.second;
                    reverse_keys[value.hash()] = key;
                }
                moves = precompute_moves(this);
            }



            operator=: (implicit out this) = {
                keys = std::unordered_map<char, coords>();
                reverse_keys = std::unordered_map<u64, char>();
                position = coords(0,0);
                moves = movemap();
            }

            operator=: (out this, that) = {
                keys = that.keys;
                reverse_keys = that.reverse_keys;
                position = that.position;
                moves = that.moves;
            }

            display: (this) = {
                for 0..<4 do (y) {
                    for 0..<3 do (x) {
                        pos := coords(x,y);
                        std::cout << " ";
                        if reverse_keys.count(pos.hash()) {
                            std::cout << reverse_keys.at(pos.hash());
                        }
                        else {
                            std::cout << '.';
                        }
                        if pos.x == position.x && pos.y == position.y {
                            std::cout << "*";
                        }
                        else {
                            std::cout << " ";
                        }
                    }
                    std::cout << std::endl;
                }
            }
        }


        playback_sequence: (this, inout robots: std::vector<robot>, sequence: std::string) -> std::string = {
            output: std::string = "";
            for sequence do (base_ch) {
                ch : char = base_ch;
                i := 0;
                if m_verbose {
                    std::cout << "Top of loop:" << std::endl;
                    j := 0;
                    for robots next j++ do (ourrobot) {
                        std::cout << " Robot (j)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$):" << std::endl;
                        ourrobot.display();
                        std::cout << std::endl;
                    }
                }
                robot_loop: for robots next i++ do (inout ourrobot) {
                    if m_verbose {
                        std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) processing '(ch)$'" << std::endl;
                    }
                    if ch == '^' {
                        ourrobot.position.y -= 1;
                    }
                    else if ch == 'v' {
                        ourrobot.position.y += 1;
                    }
                    else if ch == '<' {
                        ourrobot.position.x -= 1;
                    }
                    else if ch == '>' {
                        ourrobot.position.x += 1;
                    }
                    else if ch >= '0' && ch <= '9' {
                        // Check we're the last robot.
                        if m_verbose {
                            std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) outputting '(ch)$'" << std::endl;
                        }
                        assert(i == robots.size() - 1);
                        output += ch;
                        break robot_loop;
                    }
                    if ch == 'A' {
                        if m_verbose {
                            std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) got A, moving to next robot" << std::endl;
                        }
                        assert(ourrobot.keys.count(ourrobot.reverse_keys.at(ourrobot.position.hash())));
                        ch = ourrobot.reverse_keys.at(ourrobot.position.hash());
                        if i == robots.size() - 1 {
                            if m_verbose {
                                std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) outputting '(ch)$'" << std::endl;
                            }
                            output += ch;
                            break robot_loop;
                        }
                        // Continue to the next robot.
                    }
                    else {
                        if m_verbose {
                            std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) moved to '(ourrobot.reverse_keys.at(ourrobot.position.hash()))$'" << std::endl;
                        }
                        assert(ourrobot.reverse_keys.count(ourrobot.position.hash()));
                        break robot_loop;  // go to next character
                    }
                    if m_verbose {
                        std::cout << "Robot (i)$ at position ((ourrobot.position.x)$, (ourrobot.position.y)$) continuing with '(ch)$'" << std::endl;
                    }
                }

            }
            return output;
        }

        expand_sequence: (this, ourrobot: robot, inseq: moveset) -> moveset = {
            outseq := moveset();
            workqueue := std::deque<std::pair<std::string, std::string>>();
            for inseq do (seq) {
                _ = workqueue.emplace_back(std::make_pair(std::string(""), "A" + seq));
            }
            while workqueue.size() {
                this_pair := workqueue.front();
                stringsofar := this_pair.first;
                movestocome := this_pair.second;
                if movestocome.length() < 2U {
                    // We're done. 
                    if outseq.size() == 0 || stringsofar.length() < outseq.begin()*.length() {
                        outseq.clear();
                    }
                    if outseq.size() == 0 || stringsofar.length() == outseq.begin()*.length() {
                        _ = outseq.insert(stringsofar);
                    }
                }
                else {
                    // Grab the current move.
                    nextmovehash: u16 = srcdst(movestocome[0], movestocome[1]).hash();
                    assert(ourrobot.moves.count(nextmovehash) != 0);
                    nextmoves := ourrobot.moves.at(nextmovehash);
                    for nextmoves do (thismove) {
                        _ = workqueue.emplace_back(stringsofar + thismove + "A", std::string(movestocome.data()+1, movestocome.length()-1));
                    }
                }
                workqueue.pop_front();
            }
            return outseq;
        }

        expand_fast_by_one: (this, ourrobot: robot, inseq: moveset) -> moveset = {
            outseq := moveset();
            for inseq do (seq) {
                instr := "A" + seq;
                outstr: std::string = "";
                for 0..<(instr.length() - 1) do (i) {
                    nextmovehash: u16 = srcdst(instr[i], instr[i+1]).hash();
                    assert(ourrobot.moves.count(nextmovehash) != 0);
                    nextmoves := ourrobot.moves.at(nextmovehash);
                    outstr += nextmoves.begin()* + "A";
                }
                if outseq.size() == 0 || outstr.length() < outseq.begin()*.length() {
                    outseq.clear();
                }
                if outseq.size() == 0 || outstr.length() == outseq.begin()*.length() {
                    _ = outseq.insert(outstr);
                }
            }

            return outseq;
        }

        graph_from_sequence: (this, seq: std::string) -> movecount = {
            ourgraph := movecount();
            inseq := "A" + seq;
            for 0..<(inseq.length() - 1) do (i) {
                nextmovehash: u16 = srcdst(inseq[i], inseq[i+1]).hash();
                if !ourgraph.count(nextmovehash) {
                    ourgraph[nextmovehash] = 0;
                }
                ourgraph[nextmovehash] += 1;
            }
            ourgraph.last = inseq[inseq.length() - 1];
            return ourgraph;
        }

        expand_graph_from_moves: (this, graph: movecount, moves: movegraph) -> movecount = {
            outgraph := movecount();

            for graph do (kv) {
                movehash := kv.first;
                count := kv.second;
                assert(moves.count(movehash) != 0);
                movemap := moves.at(movehash);
                for movemap do (mvkv) {
                    moveseq := mvkv.first;
                    movecount := mvkv.second;
                    if !outgraph.count(moveseq) {
                        outgraph[moveseq] = 0;
                    }
                    outgraph[moveseq] += count * movecount;
                }
            }
            // And now set the last character.
            lastmovehash: u16 = srcdst(graph.last, 'A').hash();
            assert(moves.count(lastmovehash) != 0);
            lastmovemap := moves.at(lastmovehash);
            outgraph.last = lastmovemap.last;

            return outgraph;
        }

        run : (override inout this) -> i64 = {
            total : i64 = 0;
            // First, let's find the quickest way to do any particular task.
            // We assume that it's always quicker to turn just once.
            
            // Configuration of robots.
            robot0_config: std::unordered_map<char, coords> = (
                ('A', (2,3)),
                ('0', (1,3)),
                ('1', (0,2)),
                ('2', (1,2)),
                ('3', (2,2)),
                ('4', (0,1)),
                ('5', (1,1)),
                ('6', (2,1)),
                ('7', (0,0)),
                ('8', (1,0)),
                ('9', (2,0))
            );

            robot1_config: std::unordered_map<char, coords> = (
                ('A', (2,0)),
                ('^', (1,0)),
                ('<', (0,1)),
                ('v', (1,1)),
                ('>', (2,1))
            );

            robot0 := robot(robot0_config);
            robot1 := robot(robot1_config);
            robots := std::vector<robot>();
            robots.push_back(robot1);
            robots.push_back(robot1);
            robots.push_back(robot0);

            //seq := playback_sequence(robots, "<vA<AA>>^AvAA<^A>A<v<A>>^AvA^A<vA>^A<v<A>^A>AAvA^A<v<A>A>^AAAvA<^A>A");
            //std::cout << "Day 21 output: (seq)$" << std::endl;

            robot01_moves := robot1.precompute_moves(robot0);
            
            robot1_graph := robot1.graph_from_moves(robot1.moves);

            if m_verbose {
                std::cout << "Robot1 graph:" << std::endl;
                for robot1_graph do (kv) {
                    std::cout << " Move (kv.first >> 8:c)$(kv.first & 0xFF:c)$: (kv.second)$" << std::endl;
                }
                std::cout << std::endl;
            }
            reps: int;
            if m_part_two {
                reps = 3;
            }
            else {
                reps = 2;
            }

            for m_lines do (line) {
                if m_verbose {
                    std::cout << "Expanding line (line)$" << std::endl;
                }
                inseq := moveset();
                _ = inseq.insert(line);
                //outseq := expand_fast_by_one(robot0, inseq);
                outseq := expand_sequence(robot0, inseq);
                if m_verbose {
                    std::cout << "After first expansion, sequences are:" << std::endl;
                    for outseq do (s) {
                        std::cout << " (s)$" << std::endl;
                    }
                    std::cout << std::endl;
                }
                outgraphs := std::vector<movecount>();
                for outseq do (s) {
                    outgraphs.push_back(graph_from_sequence(s));
                }
                if m_verbose {
                    std::cout << "After first expansion, graphs are:" << std::endl;
                    for outgraphs do (outgraph) {
                        outgraph.display();
                        std::cout << std::endl;
                    }
                }
                for 0..<reps do (i) {
                    newoutgraphs := std::vector<movecount>();
                    for outgraphs do (outgraph) {
                        newoutgraphs.push_back(expand_graph_from_moves(outgraph, robot1_graph));
                    }
                    if m_verbose {
                        std::cout << "After repetition (i)$, graphs are:" << std::endl;
                        for newoutgraphs do (outgraph) {
                            outgraph.display();
                            std::cout << std::endl;
                        }
                    }
                    //newoutseq := expand_fast_by_one(robot1, outseq);
                    newoutseq := expand_sequence(robot1, outseq);
                    if m_verbose {
                        std::cout << "After repetition (i)$, sequences are:" << std::endl;
                        for newoutseq do (s) {
                            std::cout << " (s)$" << std::endl;
                        }
                        std::cout << std::endl;
                    }
                    outseq = newoutseq;
                    outgraphs = newoutgraphs;
                }
                complexity_old := outseq.begin()*.length() * std::stoi(line);
                complexity : u64 = (1ULL << 63) - 1;
                for outgraphs do (outgraph) {
                    graph_complexity: u64 = 0;
                    for outgraph do (kv) {
                        graph_complexity += kv.second;
                    }
                    if m_verbose {
                        std::cout << "Graph of (line)$ (complexity (graph_complexity)$):" << std::endl;
                        outgraph.display();
                        std::cout << std::endl;
                    }
                    if graph_complexity < complexity {
                        complexity = graph_complexity;
                    }
                }
                overall_complexity: u64 = complexity * std::stoi(line);

                if m_verbose {
                    std::cout << "Complexity in old algorithm for line (line)$ is (complexity_old)$" << std::endl;
                    std::cout << "Complexity for line (line)$ is (complexity)$ * (std::stoi(line))$ = (overall_complexity)$" << std::endl;
                }
                total += overall_complexity;
            }
            _ = robots; // Keep robots alive
            return total;
        }
    }
}